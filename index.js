// Generated by CoffeeScript 1.8.0
(function() {
  var Body, Boundary, FRAME_MARKER, Force, M, N, NORMAL_MARKER, PI, RAD, SE2, STYLE, Solver, World, Yaya, abs, atan2, cos, d3, defaultOptions, fs, sin, sqrt, _, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('yaya-core'), World = _ref.World, Body = _ref.Body, Boundary = _ref.Boundary, Force = _ref.Force, SE2 = _ref.SE2, Solver = _ref.Solver;

  _ref1 = M = Math, abs = _ref1.abs, sin = _ref1.sin, cos = _ref1.cos, atan2 = _ref1.atan2, sqrt = _ref1.sqrt, PI = _ref1.PI;

  N = require('numeric');

  RAD = 180 / PI;

  _ = require('lodash');

  d3 = require('./lib/d3.js');

  fs = require('fs');

  FRAME_MARKER = fs.readFileSync('res/frame-marker.svg');

  NORMAL_MARKER = fs.readFileSync('res/normal-marker.svg');

  STYLE = fs.readFileSync('res/style.css');

  defaultOptions = {
    timeScale: 1000,
    frameMarker: true,
    showCollision: true
  };

  module.exports = Yaya = (function(_super) {
    __extends(Yaya, _super);

    function Yaya(svgEl, options) {
      if (options == null) {
        options = {};
      }
      if (!(this instanceof Yaya)) {
        return new Yaya(svgEl, options);
      }
      this.options = _.cloneDeep(defaultOptions);
      _.merge(this.options, options);
      Yaya.__super__.constructor.call(this, this.options);
      this.svg = d3.select(svgEl);
      this.realTime = null;
      this.svg.append('style').attr('type', 'text/css').html(STYLE);
      if (this.options.frameMarker) {
        this.svg.append('defs').html(FRAME_MARKER + NORMAL_MARKER);
      }
    }

    Yaya.prototype.update = function(realTime) {
      var B, G, X, bodyList, collList, collPoints, dtRem, k, normal;
      if (this.realTime == null) {
        this.realTime = realTime;
      } else {
        dtRem = (realTime - this.realTime) / this.options.timeScale;
        this.realTime = realTime;
        if (this.options.showCollision) {
          collPoints = [];
          collList = null;
          dtRem -= this.step(dtRem, {
            collision: function(cL) {
              var contacts, normal, p, _i, _len, _results;
              collList = cL;
              _results = [];
              for (_i = 0, _len = collList.length; _i < _len; _i++) {
                contacts = collList[_i].contacts;
                _results.push((function() {
                  var _j, _len1, _ref2, _results1;
                  _results1 = [];
                  for (_j = 0, _len1 = contacts.length; _j < _len1; _j++) {
                    _ref2 = contacts[_j], p = _ref2.p, normal = _ref2.normal;
                    _results1.push(collPoints.push({
                      p: p,
                      th: atan2(normal[1], normal[0])
                    }));
                  }
                  return _results1;
                })());
              }
              return _results;
            }
          });
        }
        while (dtRem > 1e-5) {
          dtRem -= this.step(dtRem);
        }
      }
      bodyList = [];
      this.bodies.forEach(function(body, key) {
        return bodyList.push({
          body: body,
          key: key
        });
      });
      k = this.options.spaceScale;
      B = this.svg.selectAll('.yaya-body').data(bodyList, function(_arg) {
        var key;
        key = _arg.key;
        return key;
      });
      B.exit().remove();
      G = B.enter().append('g');
      G.attr('class', 'yaya-body').attr('id', function(_arg) {
        var key;
        key = _arg.key;
        return 'yaya-body-' + key;
      });
      G.filter(function(_arg) {
        var body;
        body = _arg.body;
        return body.boundary != null;
      }).append('path').attr('d', function(_arg) {
        var body;
        body = _arg.body;
        return body.boundary.pathStr;
      }).attr('class', 'yaya-boundary');
      if (this.options.frameMarker) {
        G.append('use').attr('xlink:href', '#yaya-frame-marker');
      }
      B.attr('transform', function(_arg) {
        var body, th, x, y, _ref2;
        body = _arg.body;
        _ref2 = body.frame.pos, x = _ref2.x, y = _ref2.y, th = _ref2.th;
        x = x * k;
        y = y * -k;
        th = -th * RAD;
        return "translate(" + x + "," + y + ")rotate(" + th + ")";
      });
      if (this.options.showCollision && collPoints) {
        X = this.svg.selectAll('.yaya-x').data(collPoints);
        X.exit().remove();
        X.enter().append('circle').attr('class', 'yaya-x').attr('r', 8);
        X.attr('cx', function(_arg) {
          var p;
          p = _arg.p;
          return p[0] * k;
        }).attr('cy', function(_arg) {
          var p;
          p = _arg.p;
          return p[1] * -k;
        });
        normal = this.svg.selectAll('.yaya-n').data(collPoints);
        normal.exit().remove();
        normal.enter().append('use').attr('class', 'yaya-n').attr('xlink:href', '#yaya-normal-marker');
        return normal.attr('transform', function(_arg) {
          var th, x, y, _ref2;
          (_ref2 = _arg.p, x = _ref2[0], y = _ref2[1]), th = _arg.th;
          x = x * k;
          y = y * -k;
          th = -th * RAD;
          return "translate(" + x + "," + y + ")rotate(" + th + ")";
        });
      }
    };

    return Yaya;

  })(World);

  _.merge(module.exports, {
    Body: Body,
    Force: Force,
    SE2: SE2,
    Solver: Solver
  });

}).call(this);

//# sourceMappingURL=index.js.map
